"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAndWrite = void 0;
const path = require("path");
const fs_extra_1 = require("fs-extra");
const bluebird_lst_1 = require("bluebird-lst");
const JsDocGenerator_1 = require("./JsDocGenerator");
function computeModuleNameMappings(generator) {
    const mainModuleName = generator.moduleName;
    const mainPsi = generator.moduleNameToResult.get(mainModuleName);
    const oldModulePathToNew = new Map();
    for (const [id, names] of generator.mainMappings) {
        const psi = generator.moduleNameToResult.get(id);
        for (const name of names) {
            if (moveMember(psi.classes, mainPsi.classes, name, mainModuleName)) {
                oldModulePathToNew.set(`module:${id}.${name}`, `module:${mainModuleName}.${name}`);
                continue;
            }
            moveMember(psi.functions, mainPsi.functions, name) || moveMember(psi.members, mainPsi.members, name);
        }
    }
    return oldModulePathToNew;
}
function moveMember(members, mainPsiMembers, name, newId = null) {
    const index = members.findIndex(it => it.name === name);
    if (index < 0) {
        return false;
    }
    const member = members[index];
    if (newId != null) {
        member.modulePath = "module:" + newId;
    }
    mainPsiMembers.push(member);
    members.splice(index, 1);
    return true;
}
async function generateAndWrite(basePath, config, tsConfig) {
    let packageData = { name: "packageJsonNotDefined" };
    try {
        packageData = await fs_extra_1.readJson(path.join(basePath, "package.json"));
    }
    catch (e) {
    }
    const options = typeof tsConfig.jsdoc === "string" ? { out: tsConfig.jsdoc } : tsConfig.jsdoc;
    if (options.out == null) {
        throw new Error("Please specify out in the tsConfig.jsdoc (https://github.com/develar/ts2jsdoc#generate-jsdoc-from-typescript)");
    }
    const generator = JsDocGenerator_1.generate(basePath, config, packageData.name, packageData == null ? null : packageData.main, options);
    const out = path.resolve(basePath, options.out);
    console.log(`Generating JSDoc to ${out}`);
    await fs_extra_1.emptyDir(out);
    const oldModulePathToNew = computeModuleNameMappings(generator);
    const exampleDir = options.examples == null ? null : path.resolve(basePath, options.examples);
    const existingClassExampleDirs = exampleDir == null ? null : new Set((await fs_extra_1.readdir(exampleDir)).filter(it => it[0] != "." && !it.includes(".")));
    for (const [moduleId, psi] of generator.moduleNameToResult.entries()) {
        const modulePathMapper = oldPath => {
            if (!oldPath.startsWith("module:")) {
                return oldPath;
            }
            const result = oldModulePathToNew.get(oldPath);
            if (result != null) {
                return result;
            }
            if (moduleId === generator.moduleName && options.externalIfNotMain != null) {
                // external:electron-builder/out/platformPackager.PlatformPackager is not rendered by jsdoc2md,
                // only PlatformPackager
                const dotIndex = oldPath.lastIndexOf(".");
                const value = oldPath.substring(dotIndex + 1);
                externalToModuleName.set(value, oldPath.substring(oldPath.indexOf(":") + 1, dotIndex));
                return `external:${value}`;
            }
            return oldPath;
        };
        let result = "";
        const externalToModuleName = new Map();
        for (const d of copyAndSort(psi.members)) {
            if (d.kind == null) {
                result += generator.renderer.renderVariable(d, modulePathMapper);
            }
            else {
                result += generator.renderer.renderMember(d);
            }
        }
        for (const d of copyAndSort(psi.classes)) {
            let examples = [];
            if (existingClassExampleDirs != null && existingClassExampleDirs.has(d.name)) {
                const dir = path.join(exampleDir, d.name);
                examples = await bluebird_lst_1.default.map((await fs_extra_1.readdir(dir)).filter(it => it[0] != "." && it.includes(".")), async (it) => {
                    const ext = path.extname(it);
                    return {
                        name: path.basename(it, ext),
                        content: await fs_extra_1.readFile(path.join(dir, it), "utf8"),
                        lang: ext
                    };
                });
            }
            result += generator.renderer.renderClassOrInterface(d, modulePathMapper, examples);
        }
        for (const d of copyAndSort(psi.functions)) {
            result += generator.renderer.renderMethod(d, modulePathMapper, null);
        }
        if (result === "") {
            continue;
        }
        let externalJsDoc = "";
        for (const [external, moduleId] of externalToModuleName) {
            externalJsDoc += `/**\n* @external ${external}\n* @see ${options.externalIfNotMain}#module_${moduleId}.${external}\n*/\n`;
        }
        await fs_extra_1.writeFile(path.join(out, moduleId.replace(/\//g, "-") + ".js"), `${externalJsDoc}/** 
 * @module ${moduleId}
 */

${result}`);
    }
}
exports.generateAndWrite = generateAndWrite;
function copyAndSort(members) {
    return members.slice().sort((a, b) => a.name.localeCompare(b.name));
}
//# sourceMappingURL=manager.js.map