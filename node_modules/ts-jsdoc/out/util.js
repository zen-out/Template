"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processTree = exports.checkErrors = exports.transpilePaths = exports.transpile = void 0;
const ts = require("typescript");
const path = require("path");
const fs_extra_1 = require("fs-extra");
const bluebird_lst_1 = require("bluebird-lst");
function transpile(transpilator) {
    const paths = process.argv.slice(2);
    if (paths.length == 0) {
        paths.push(process.cwd());
    }
    return transpilePaths(paths, transpilator);
}
exports.transpile = transpile;
function transpilePaths(paths, transpilator) {
    return bluebird_lst_1.default.map(paths, basePath => {
        return build(basePath, transpilator)
            .catch(e => {
            if (e == null) {
                return;
            }
            if (!(e instanceof CompilationError)) {
                throw e;
            }
            for (const diagnostic of e.errors) {
                if (diagnostic.file == null) {
                    console.log(diagnostic.messageText);
                    continue;
                }
                const location = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
                const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
                console.log(`${diagnostic.file.fileName} (${location.line + 1}, ${location.character + 1}): ${message}`);
            }
            process.exit(-1);
            return;
        });
    });
}
exports.transpilePaths = transpilePaths;
async function build(basePath, transpilator) {
    const tsConfigPath = path.join(basePath, "tsconfig.json");
    const jsonResult = ts.parseConfigFileTextToJson(tsConfigPath, await fs_extra_1.readFile(tsConfigPath, "utf8"));
    if (jsonResult.error != null) {
        throw new CompilationError([jsonResult.error]);
    }
    const result = ts.parseJsonConfigFileContent(jsonResult.config, ts.sys, basePath);
    checkErrors(result.errors);
    await transpilator(basePath, result, jsonResult.config);
}
function checkErrors(errors) {
    if (errors.length !== 0) {
        throw new CompilationError(errors);
    }
}
exports.checkErrors = checkErrors;
class CompilationError extends Error {
    constructor(errors) {
        super("Compilation error");
        this.errors = errors;
    }
}
function processTree(sourceFile, replacer) {
    function visit(node) {
        if (node.flags & ts.ModifierFlags.Private) {
            // skip private nodes
            return;
        }
        if (!replacer(node)) {
            ts.forEachChild(node, visit);
        }
    }
    visit(sourceFile);
}
exports.processTree = processTree;
//# sourceMappingURL=util.js.map