{"version":3,"file":"JsDocRenderer.js","sourceRoot":"","sources":["../src/JsDocRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\"\nimport * as path from \"path\"\nimport { Example, JsDocGenerator, ModulePathMapper } from \"./JsDocGenerator\"\nimport { parse as parseJsDoc, Tag } from \"doctrine\"\nimport { Class, Descriptor, MethodDescriptor, Property, Type, Variable } from \"./psi\"\n\nexport class JsDocRenderer {\n  indent: string = \"\"\n\n  constructor(private readonly generator: JsDocGenerator) {\n  }\n\n  normalizeDescription(comment: string) {\n    return this.indent + \" * \" + comment\n      .split(\"\\n\")\n      .map(it => it.trim())\n      .filter(it => it != \"*/\" && it.length > 0)\n      .join(`\\n${this.indent} * `)\n  }\n\n  normalizeDescription2(comment: string) {\n    return this.indent + \" * \" + comment\n      .split(\"\\n\")\n      .map(it => it.trim())\n      .join(`\\n${this.indent} * `)\n  }\n\n  formatComment(node: ts.Node, tags: Array<string>, description?: string): string {\n    const indent = this.indent\n\n    let result = `${indent}/**\\n`\n\n    if (description == null) {\n      const comment = JsDocRenderer.getComment(node)\n      if (comment != null) {\n        result += `${this.normalizeDescription(comment)}\\n`\n      }\n    }\n    else if (description.length > 0) {\n      result += `${this.normalizeDescription2(description)}\\n`\n    }\n\n    // must be added after user description\n    if (tags.length > 0) {\n      for (const tag of tags) {\n        result += `${indent} * ${tag}\\n`\n      }\n    }\n\n    result += `${indent} */\\n`\n    return result\n  }\n\n  renderClassOrInterface(descriptor: Class, modulePathMapper: ModulePathMapper, examples?: Array<Example>): string {\n    this.indent = \"\"\n\n    const tags: Array<string> = []\n\n    if (descriptor.isInterface) {\n      tags.push(`@interface ${descriptor.modulePath}.${descriptor.name}`)\n    }\n\n    for (const parent of descriptor.parents) {\n      // ignore <> type params because JsDoc expects namepath, but not type expression\n      tags.push(`@extends ${renderType(parent, modulePathMapper, true)}`)\n    }\n\n    JsDocRenderer.renderProperties(descriptor.properties, tags, modulePathMapper)\n\n    if (examples != null) {\n      for (const example of examples) {\n        tags.push(`@example <caption>${example.name}</caption> @lang ${example.lang}\\n * ${example.content.trim().split(\"\\n\").join(\"\\n * \")}`)\n      }\n    }\n\n    let result = this.formatComment(descriptor.node, tags, parseExistingJsDoc(descriptor.node, tags) || \"\")\n    result += `export class ${descriptor.name} {\\n`\n\n    this.indent = \"  \"\n    for (const method of descriptor.methods) {\n      result += this.renderMethod(method, modulePathMapper, descriptor)\n      if (method !== descriptor.methods[descriptor.methods.length - 1]) {\n        result += \"\\n\"\n      }\n    }\n    this.indent = \"\"\n\n    result += \"}\\n\\n\"\n    return result\n  }\n\n  renderMethod(method: MethodDescriptor, modulePathMapper: ModulePathMapper, classDescriptor: Class | null): string {\n    const tags = method.tags.slice()\n\n    const paramNameToInfo = new Map<string, Tag>()\n    let returns: Tag | null = null\n\n    const parsed = method.jsDoc\n    if (parsed != null) {\n      for (const tag of parsed.tags) {\n        if (tag.title === \"param\") {\n          if (tag.name != null) {\n            paramNameToInfo.set(tag.name, tag)\n          }\n        }\n        else if (tag.title === \"returns\" || tag.title === \"return\") {\n          returns = tag\n        }\n        else {\n          tags.push(printTag(tag))\n        }\n      }\n    }\n\n    for (const param of method.node.parameters) {\n      let name = (<ts.Identifier>param.name).text\n      let text = `@param`\n\n      const type = param.type\n      if (type != null) {\n        let namePathByNode = this.generator.getTypeNamePathByNode(type)\n        if (namePathByNode == null) {\n          console.warn(\"cannot get namePathByNode for \" + type)\n        }\n        else {\n          text += ` ${renderTypes(namePathByNode!!, modulePathMapper)}`\n        }\n      }\n\n      text += ` ${name}`\n      const tag = paramNameToInfo.get(name)\n      if (tag != null && tag.description != null) {\n        text += ` ${tag.description}`\n      }\n      tags.push(text)\n    }\n\n    if (classDescriptor != null) {\n      // https://github.com/jsdoc3/jsdoc/issues/1137#issuecomment-281257286\n      tags.push(`@function ${classDescriptor.modulePath}.${classDescriptor.name}#${method.name}`)\n    }\n\n    const signature = this.generator.program.getTypeChecker().getSignatureFromDeclaration(method.node)!!\n    const returnTypes = this.generator.getTypeNames(signature.getReturnType(), method.node)!!\n    // http://stackoverflow.com/questions/4759175/how-to-return-void-in-jsdoc\n    if (!returnTypes.includes(\"void\")) {\n      let text = `@returns ${renderTypes(returnTypes, modulePathMapper)}`\n      if (returns != null) {\n        text += ` ${returns.description}`\n      }\n      tags.push(text)\n    }\n\n    let result = this.formatComment(method.node, tags, (parsed == null ? \"\" : parsed.description) || \"\")\n    result += `${this.indent}`\n    if (method.node.kind === ts.SyntaxKind.FunctionDeclaration) {\n      result += \"export function \"\n    }\n    result += `${method.name}() {}\\n`\n    return result\n  }\n\n  static getComment(node: ts.Node): string | null {\n    const sourceFile = node.getSourceFile()\n    const leadingCommentRanges = ts.getLeadingCommentRanges(sourceFile.text, node.pos)\n    if (leadingCommentRanges == null || leadingCommentRanges.length === 0) {\n      return null\n    }\n\n    const commentRange = leadingCommentRanges[0]\n    if (sourceFile.text[commentRange.pos] === \"/\" && sourceFile.text[commentRange.pos + 1] === \"*\" && sourceFile.text[commentRange.pos + 2] == \"*\") {\n      return sourceFile.text.slice(commentRange.pos + 3, commentRange.end).trim()\n    }\n    return null\n  }\n\n  renderVariable(descriptor: Variable, modulePathMapper: ModulePathMapper): string {\n    this.indent = \"\"\n\n    const tags = [`@type ${renderTypes(descriptor.types, modulePathMapper)}`]\n\n    if (descriptor.isConst) {\n      tags.push(\"@constant\")\n    }\n\n    let result = this.formatComment(descriptor.node, tags)\n    // jsdoc cannot parse const, so, we always use var\n    result += `export var ${descriptor.name}\\n`\n    return result\n  }\n\n  renderMember(descriptor: Descriptor) {\n    const tags = [\n      \"@enum {number}\"\n    ]\n\n    if (descriptor.readonly) {\n      tags.push(\"@readonly\")\n    }\n    if (descriptor.properties != null) {\n      for (const property of descriptor.properties) {\n        tags.push(`@property ${property.name}`)\n      }\n    }\n\n    let result = this.formatComment(descriptor.node!, tags)\n    result += `export var ${descriptor.name}\\n`\n    return result\n  }\n\n  // form http://stackoverflow.com/questions/10490713/how-to-document-the-properties-of-the-object-in-the-jsdoc-3-tag-this\n  // doesn't produce properties table, so, we use property tags\n  private static renderProperties(properties: Array<Property>, tags: Array<string>, modulePathMapper: ModulePathMapper): void {\n    loop:\n    for (const descriptor of properties) {\n      const node = descriptor.node\n      const existingJsDoc = JsDocRenderer.getComment(node)\n      const parsed = existingJsDoc == null ? null : parseJsDoc(existingJsDoc, {unwrap: true})\n      let defaultValue = descriptor.defaultValue\n      let isOptional = descriptor.isOptional\n      let description = parsed == null ? \"\" : parsed.description\n      if (parsed != null) {\n        for (const tag of parsed.tags) {\n          switch (tag.title) {\n            case \"default\":\n              defaultValue = tag.description\n              break\n\n            case \"private\":\n              continue loop\n\n            case \"required\":\n              isOptional = false\n              break\n\n            case \"see\":\n              description += `\\nSee: ${tag.description}`\n              break\n\n            case \"deprecated\":\n              description += `\\nDeprecated: {tag.description}`\n              break\n\n            default: {\n              const sourceFile = node.getSourceFile()\n              const leadingCommentRanges = ts.getLeadingCommentRanges(sourceFile.text, node.pos)!!\n              const position = sourceFile.getLineAndCharacterOfPosition(leadingCommentRanges[0].pos)\n              console.warn(`${path.basename(sourceFile.fileName)} ${position.line + 1}:${position.character} property level tag \"${tag.title}\" are not supported, please file issue`)\n            }\n          }\n        }\n      }\n\n      let result = `@property ${renderTypes(descriptor.types, modulePathMapper)} `\n\n      if (isOptional) {\n        result += \"[\"\n      }\n      result += descriptor.name\n\n      if (defaultValue != null) {\n        result += `=${defaultValue}`\n      }\n\n      if (isOptional) {\n        result += \"]\"\n      }\n\n      if (description != null) {\n        description = description.trim()\n        if (description.length > 0) {\n          // one \\n is not translated to break as markdown does (because in the code newline means that we don't want to use long line and have to break)\n          description = description\n            .replace(/\\n\\n/g, \"<br><br>\")\n            .replace(/\\n/g, \" \")\n          // http://stackoverflow.com/questions/28733282/jsdoc-multiline-description-property\n          result += ` ${description}`\n        }\n      }\n      tags.push(result)\n    }\n  }\n}\n\nfunction parseExistingJsDoc(node: ts.Node, tags: Array<string>): string | null {\n  const existingJsDoc = JsDocRenderer.getComment(node)\n  const parsed = existingJsDoc == null ? null : parseJsDoc(existingJsDoc, {unwrap: true})\n  if (parsed != null) {\n    for (const tag of parsed.tags) {\n      tags.push(printTag(tag))\n    }\n  }\n\n  return parsed == null ? null : parsed.description\n}\n\nfunction printTag(tag: Tag) {\n  let text = `@${tag.title}`\n\n  const caption = (<any>tag).caption\n  if (caption != null) {\n    text += ` <caption>${caption}</caption>`\n  }\n\n  if (tag.description != null) {\n    text += ` ${tag.description}`\n  }\n  return text\n}\n\n// (oldPath: string) => oldPath\n\nfunction renderTypes(names: Array<string | Type>, modulePathMapper: ModulePathMapper): string {\n  return `{${_renderTypes(names, modulePathMapper)}}`\n}\n\nfunction _renderTypes(names: Array<string | Type>, modulePathMapper: ModulePathMapper): string {\n  return names.map(it => renderType(it, modulePathMapper)).join(\" | \")\n}\n\nfunction renderType(name: string | Type, modulePathMapper: ModulePathMapper, ignoreSubtypes = false): string {\n  if (typeof name === \"string\") {\n    return modulePathMapper(name)\n  }\n  const type = <Type>name\n  if (ignoreSubtypes) {\n    return modulePathMapper(type.name)\n  }\n  return modulePathMapper(type.name) + \"<\" + _renderTypes(type.subTypes, modulePathMapper) + \">\"\n}"]}